
说一说TCP 的四次挥手
tcp 的解决阻塞算法的过程

> osi 为什么有七层？

* 应用层：为应用程序提供服务;                                  常见的协议有：FTP、SMTP、HTTP、DNS等

* 表示层：数据格式转换，数据加密；                                                 CSS、HTML、GIF

* 会话层：建立、维护和管理会话；                                                     HTTP、SSH、SMTP、FTP

* 传输层：建立、维护和管理端到端的连接，控制数据传输的方式；  TCP/UDP

* 网络层：数据传输线路选择，IP地址及路由选择；                            IP/ICMP

* 数据链路层：提供介质访问和链路管理；                                          ARP/RARP/MAC

* 物理层：以二进制形式在物理媒介上传输数据。                                DSL




TCP 链接的三次握手 : 双方都能明确自己和对方的收、发能力是正常的

第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的；
第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的
第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的

1. 第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。
2. 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。 
3. 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。

TCP 四次挥手 -> 断开连接 
1. 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 
2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号,等待来自客户端的最后一个ACK。 
3. 服务器端准备好关闭连接时，发送一个FIN给客户端
4. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

主要有两个原因


> 为什么TCP三次握手？两次不行吗？
防止已经失效的请求又传送到了服务端，建立了多余的连接，造成资源的浪费；两次握手只能保证单向连接是畅通的，如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

> TCP四次挥手？两次不行吗？
因为TCP是全双工通信，每个方向都要发送关闭请求，另一方相应的返回确认信息




> HTTP 是什么 

他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接

> HTTP 过程
* 对个网址进行DNS域名解析，得到对应的IP地址
* 根据这个IP，找到对应的服务器，发起TCP的三次握手(与服务器建立连接)
* 建立TCP连接后发起HTTP请求
* 服务器响应HTTP请求，浏览器得到html代码
* 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）
* 浏览器对页面进行渲染呈现给用户
* 服务器关闭关闭TCP连接


> HTTPS

1. 你的客户端去请求一个TLS连接，这个过程是通过tcp，不是通过http。
2. 服务器把他的证书发给你。
3. 客户端去验证这个服务器证书是不是真的。
4. 验证通过，客户端信任服务器，和服务器协商对称密钥。
5. 使用对称密钥开始通讯。 只有最后一步才是http通讯，前面都是tcp

