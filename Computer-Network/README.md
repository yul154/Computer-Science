OSI七层
- 应用层
  - HTTP
  - HTTPS
- 网络层
  -   TCP
    - 三次握手和四次挥手  
    - 滑动窗口和流量控制
  -   UDP  


----
# 理解全局网络层次


OSI七层参考模型的各个层次的划分遵循下列原则： 
* 同一层中的各网络节点都有相同的层次结构，具有同样的功能。 
* 同一节点内相邻层之间通过接口(可以是逻辑接口)进行通信。 
* 七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。 
* 不同节点的同等层按照协议实现对等层之间的通信



<img width="572" alt="Screen Shot 2021-12-13 at 8 03 04 PM" src="https://user-images.githubusercontent.com/27160394/145808937-989af0dc-ecdf-4443-87ae-a6378200e1cc.png">

OSI依层次结构来划分：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）

|层|介绍|常用协议|
|---|---|------|
|物理层(PhysicalLayer)|以二进制形式在物理媒介上传输数据，物理层通过媒介传输比特, 为上层协议提供了一个传输数据的物理媒体|DSL|
|数据链路层(DataLinkLayer) |提供介质访问和链路管理；为网络层提供数据链路的链接 |ARP/RARP/MAC|
| 网络层(Network) | 数据传输线路选择，IP地址及路由选择，通过寻址建立两个节点的连接，网络层的任务就是选择合适的网间路由和交换结点,确保数据及时传送|IP/ICMP|
| 传输层（Transport) | 建立、维护和管理端到端的连接，控制数据传输的方式。数据单元也称作数据包(packets)。| TCP/UDP|
| 会话层(Session) |建立、维护和管理会话，建立2个节点间的端连接| HTTP、SSH、SMTP、FTP|
| 表示层（Presentation) | 数据格式转换，数据加密，两个通信系统的表达方式 | CSS、HTML、GIF|
| 应用层（Application）| 为应用程序提供服务,进程间的通信  |  FTP、SMTP、HTTP、DNS|

> osi 为什么有七层？

1.易于实现和标准化各层独立，就可以把大问题分割成多个小问题，利于实现；

2.灵活性好：如果某一层发生变化，只要接口不变，不会影响其他层；

3.分层后，用户只关心用到的应用层，其他层用户可以复用；

4. 各层之间相互独立：高层不需要知道底层的功能是采取硬件来实现的，只需要知道通过底层的接口来获得所需要的服务。
----

# TCP/UDP

UDP 和 TCP 的特点
* 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。例如：视频传输、实时通信
* 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）



## TCP 首部格式

tcp的6种标志位的分别代表：
* 序号 seq ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。[301,400]为序号301的数据长度，下一个则为401
* 确认号 ack ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
* 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
* 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
* 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
* 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
* 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。



TCP 链接的三次握手 : 双方都能明确自己和对方的收、发能力是正常的

第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的；
第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的
第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的

1. 第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。 SYN=1，ACK=0，选择一个初始的序号 seq = x。
2. 第二次握手：服务器B收到SYN包，必须确认客户A的SYN，同时自己也发送一个SYN包（SYN=j，即SYN+ACK包，此时服务器B进入SYN_RECV状态。SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 seq = y
3. 第三次握手：客户端A收到服务器B的SYN＋ACK包,向服务器B发送确认包ACK（ACK=y+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。确认号为 ack = y+1，序号为 seq = x+1。

> 为什么TCP三次握手？两次不行吗？
防止已经失效的请求又传送到了服务端，建立了多余的连接，造成资源的浪费；
* 两次握手只能保证单向连接是畅通的，如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认
* 现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为是A有发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。
* 由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。




TCP 四次挥手 -> 断开连接 
1. 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 FIN =1, seq =u
2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号,等待来自客户端的最后一个ACK。 ACK =1, seq = v, ack = u+1
3. 服务器端准备好关闭连接时，发送一个FIN给客户端
4. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。


> TCP四次挥手？两次不行吗？
因为TCP是全双工通信，每个方向都要发送关闭请求，另一方相应的返回确认信息

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。


### 滑动窗口和流量控制

TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收



说一说TCP 的四次挥手
tcp 的解决阻塞算法的过程


---

> HTTP 是什么 

他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接

> HTTP 过程
* 对个网址进行DNS域名解析，得到对应的IP地址,根据这个IP，找到对应的服务器
* 发起TCP的三次握手(与服务器建立连接)
* 建立TCP连接后发起HTTP请求
* 服务器处理请求并返回 HTTP 报文
* 浏览器解析渲染页面
* 连接结束


> HTTPS

1. 你的客户端去请求一个TLS连接，这个过程是通过tcp，不是通过http。
2. 服务器把他的证书发给你。
3. 客户端去验证这个服务器证书是不是真的。
4. 验证通过，客户端信任服务器，和服务器协商对称密钥。
5. 使用对称密钥开始通讯。 只有最后一步才是http通讯，前面都是tcp


## HTTP 和 HTTPS 的区别？
1. 端口 ：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。
2. 安全性和资源消耗： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源

## HTTP 长连接, 短连接

* 短连接 : 客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接
* 长连接 :，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间


-----
# Cookie 的作用是什么? 和 Session 有什么区别？

Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

Cookie 一般用来保存用户信息 
* 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；
* 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；
* 登录一次网站后访问网站其他页面不需要重新登录。

Session 的主要作用就是通过服务端记录用户的状态。 
* 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。
* 服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密

-----
