OSI七层
- 应用层
  - HTTP
  - HTTPS
- 网络层
  -   TCP
    - 三次握手和四次挥手  
    - 滑动窗口和流量控制
  -   UDP  

----
# 理解全局网络层次

OSI七层参考模型的各个层次的划分遵循下列原则： 
* 同一层中的各网络节点都有相同的层次结构，具有同样的功能。 
* 同一节点内相邻层之间通过接口(可以是逻辑接口)进行通信。 
* 七层结构中的每一层使用下一层提供的服务，并且向其上层提供服务。 
* 不同节点的同等层按照协议实现对等层之间的通信



<img width="572" alt="Screen Shot 2021-12-13 at 8 03 04 PM" src="https://user-images.githubusercontent.com/27160394/145808937-989af0dc-ecdf-4443-87ae-a6378200e1cc.png">

OSI依层次结构来划分：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）

|层|介绍|常用协议|
|---|---|------|
|物理层(PhysicalLayer)|以二进制形式在物理媒介上传输数据，实现相邻计算机节点之间比特流的透明传送, 为上层协议提供了一个传输数据的物理媒体|DSL|
|数据链路层(DataLinkLayer) |不同的网络类型,发送数据的机制不同，数据链路层就是将数据包封装成能够在不同的网络传输的帧,为网络层提供数据链路的链接 |ARP/RARP/MAC|
| 网络层(Network) | 网络层的任务就是选择合适的网间路由和交换结点,确保数据及时传送，数据传输线路选择，IP地址及路由选择，通过寻址建立两个节点的连接|IP/ICMP|
| 传输层（Transport) | 负责向两台主机进程之间的通信提供通用的数据传输服务 。数据单元也称作数据包(packets)。| TCP/UDP|
| 会话层(Session) |建立、维护和管理会话，通信的应用程序之间建立会话| HTTP、SSH、SMTP、FTP|
| 表示层（Presentation) | 数据格式转换，数据加密，两个通信系统的表达方式 | CSS、HTML、GIF|
| 应用层（Application）| 为应用程序提供服务,进程间的通信，应用层交互的数据单元称为报文| 应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则：FTP、SMTP、HTTP、DNS|

> osi 为什么有七层？

1.易于实现和标准化各层独立，就可以把大问题分割成多个小问题，利于实现；

2.灵活性好：如果某一层发生变化，只要接口不变，不会影响其他层；

3.分层后，用户只关心用到的应用层，其他层用户可以复用；

4. 各层之间相互独立：高层不需要知道底层的功能是采取硬件来实现的，只需要知道通过底层的接口来获得所需要的服务。
----
# 传输层（Transport)

## TCP 首部格式

tcp的6种标志位的分别代表：
* 序号 seq ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。[301,400]为序号301的数据长度，下一个则为401
* 确认号 ack ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
* 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
* 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
* 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
* 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
* 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。


## TCP/UDP

UDP 和 TCP 的特点
* 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。例如：视频传输、实时通信
  * UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。
  * 支持一对一、一对多、多对一和多对多的交互通信, 
  * 虽然 UDP 不提供可靠交付，但在某些情况下UDP却是一种最有效的工作方式（一般用于即时通信），
  * 比如： QQ 语音、 QQ 视频 、直播等等 
* 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，
    * 提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），
    * 每一条 TCP 连接只能是点对点的（一对一）
    * 在传送数据之前必须先建立连接，数据传送结束后要释放连接
    * ,TCP 一般用于文件传输、发送和接收邮件、远程登录等场景


|TCP|UDP|
|---|---|
|TCP 是面向连接的运输层协议。|UDP 是无连接的，即发送数据之前不需要建立连接。|
|TCP 提供可靠交付的服务|UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。|
||UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。|
|每一条 TCP 连接只能有两个端点(endpoint)，每一条 TCP 连接只能是点对点的（一对一）|UDP 支持一对一、一对多、多对一和多对多的交互通信。|
|首部最低20个字节|UDP 的首部开销小，只有 8 个字节|


### TCP 链接的三次握手
> 双方都能明确自己和对方的收、发能力是正常的

* 第一次握手：客户端–发送带有 SYN 标志的数据包（客户端发送网络包），服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的；
* 第二次握手：服务端–发送带有 SYN/ACK 标志的数据包（服务端发包），客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的
* 第三次握手：客户端–发送带有带有 ACK 标志的数据包(客户端发包)，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的

1. 第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。 SYN=1，ACK=0，选择一个初始的序号 seq = x。
2. 第二次握手：服务器B收到SYN包,必须确认客户A的SYN,同时自己也发送一个SYN包（SYN=j,即SYN+ACK包，此时服务器B进入SYN_RECV状态。SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 seq = y
3. 第三次握手：客户端A收到服务器B的SYN＋ACK包,向服务器B发送确认包ACK（ACK=y+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。确认号为 ack = y+1，序号为 seq = x+1。

> 为什么TCP三次握手？两次不行吗？

防止已经失效的请求又传送到了服务端，建立了多余的连接，造成资源的浪费；
* 两次握手只能保证单向连接是畅通的，如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认
* 现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为是A有发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。
* 由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。


### TCP 四次挥手 -> 断开连接 

1. 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 FIN =1, seq =u
2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号,等待来自客户端的最后一个ACK。 ACK =1, seq = v, ack = u+1
3. 服务器端准备好关闭连接时，发送一个FIN给客户端
4. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。


> TCP四次挥手？两次不行吗？

因为TCP是全双工通信，每个方向都要发送关闭请求，另一方相应的返回确认信息

因为可能服务端还有数据没传完啊
* 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。


## TCP 协议如何保证可靠传输

* 应用数据被分割成TCP认为最适合发送的数据块。 
* TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 
* 校验和: TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
* TCP的接收端会丢弃重复的数据。 
* 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）
* 拥塞控制 :  当网络拥塞时，减少数据的发送。 
* ARQ协议 : 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。 
* 超时重传: 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段

### ARQ 协议

自动重传请求(Automatic Repeat-reQuest，ARQ)是 OSI 模型中数据链路层和传输层的错误纠正协议之一。
* 它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。
* 如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。
* ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议

#### 停止等待 ARQ 协议
* 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。
* 如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组
* 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。

确认丢失
* 确认丢失 : 确认消息在传输过程丢失。
  * 当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。
  * 而 A 并不知道，在超时计时过后,A重传M1消息，B再次收到该消息后采取以下两点措施：
    1. 丢弃这个重复的 M1 消息，不向上层交付。 
    2. 向A发送确认消息(不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失)

确认迟到
* 确认消息在传输过程中迟到
  * A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。
  * 此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）
  * 处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。 


#### 连续 ARQ 协议
* 发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。
* 接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。



### 滑动窗口和流量控制
> TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收


窗口是缓存的一部分，用来暂时存放字节流
* 发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。
* 如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。
* 

接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。


### 拥塞控制（Congestion Handling）
> 在某段时间，到达通信网络中某一部分的分组数量过多，使得该部分网络来不及处理，网络的性能就要变坏。这种情况就叫拥塞

拥塞控制是一种调整传输控制协议（TCP）连接上单次发送的分组数量的算法，通过增减单次发送量逐步调整，使之逼近当前网络的承载量
* 拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。
* 拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷
* 拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素
* 流量控制往往是点对点通信量的控制，是个端到端的问题



为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd)的状态变量
* 拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。
* 发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。 


在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生

### TCP 的拥塞控制采用了四种算法

假设 : 拥塞控制假设分组的丢失都是由网络繁忙造成的
* 收到一条新确认.表明当前的单次发送量小于网络的承载量.此时可以增加单次发送量.若当前单次发送量小于慢启动阈值（ssthreash），则单次发送量加倍（乘以2），即指数增长；否则单次发送量加1，即线性增长。
* 收到三条对同一分组的确认，即三条重复的确认。说明网络有一点儿繁忙。此时单次发送量减半，慢启动阈值（ssthreash）约等于单次发送量，进入线性增长阶段
* 对某一个分组的确认迟迟未到，即超时。说明网络比上一情况中的更加繁忙。此时慢启动阈值=单次发送量÷2，单次发送量=1，进入慢启动阶段


1. 慢开始: 当主机开始发送数据时,如果立即把大量数据字节注入到网络,那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍


2. 拥塞避免: 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间RTT就把发送放的 cwnd 加 1
  * 其指数级增长很快就会使网络出现拥塞现象，因为某些点上可能达到了互联网的容量,进入慢启动阶段后，拥塞窗口会指数级增长，如果拥塞窗口大于慢启动阈值（ssthreash），执行拥塞避免算法
  * 两种分组丢失的指示：发生超时和接收到重复的确认
      * 发生超时，指源主机在超时定时器溢出时没有收到目的主机对某一分组的ACK；
      * 接收到重复确认，指在源主机的超时定时器溢出前，连续收到3个或3个以上收对某一分组的ACK。
  * 当发现超时或接收到3次重复确认时，则表示有丢包事件，此时网络已发生拥塞现象，要进行相应的拥塞控制
    * 只要发送方判断网络出现拥塞（其根据就是没有按时收到确认),就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。
    * 然后把拥塞窗口cwnd重新设置为1,执行拥塞避免算法时，由于慢启动阈值（ssthreash）已经存在，拥塞窗口大小不再翻倍增长，而是线性增加


4. 快重传和快恢复 :  在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法,它能快速恢复丢失的数据包
  *  没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送
  *  有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段
  *  有了 FRR，就不会因为重传时要求的暂停被耽误。 　
  *  当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

1. 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。
2. 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。
3. 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。


> 如何区分流量控制和拥塞控制

拥塞控制：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况

流量控制：流量控制是作用于接收者的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的

```
* 拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。
* 拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。
* 流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。
* 流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。
* 流量控制属于通信双方协商；拥塞控制涉及通信链路全局。
* 流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。
* 实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。
```



---
# 应用层

## URI 和 URL 的区别是什么?
* URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。 
* URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。 
* URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。 #


##  HTTP 

他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接

> HTTP 过程

* 对个网址进行DNS域名解析，得到对应的IP地址,根据这个IP，找到对应的服务器
* 发起TCP的三次握手(与服务器建立连接)
* 发起HTTP请求
* 服务器处理请求并返回 HTTP 报文
* 浏览器解析渲染页面
* 连接结束


> HTTPS

1. 你的客户端去请求一个TLS连接，这个过程是通过tcp，不是通过http。
2. 服务器把他的证书发给你。
3. 客户端去验证这个服务器证书是不是真的。
4. 验证通过，客户端信任服务器，和服务器协商对称密钥。
5. 使用对称密钥开始通讯。 只有最后一步才是http通讯，前面都是tcp


## HTTP的请求方法

|HTTP方法|描述|
|-------|----|
|GET|获取资源|
|HEAD|  获取报文首部|
|PUT|上传文件|
|DELETE | 请求服务器删除某一个资源 |
| POST | 向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）|
| PATCH |  对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改|
| OPTIONS |查询指定的 URL 能够支持的方法 |

> GET和POST的区别：
* 对资源的影响：GET一般用于获取或者查询资源信息，意味着对同一个URL的多个请求返回的结果一样（幂等），没有修改资源的状态（安全）；而POST一般用于更新资源信息，POST既不是安全的也不是幂等的
传递的信息量：
* 采用GET方法时，客户端把发送的数据添加到URL后面（即HTTP协议头中），使用“？”连接，各个变量用“&”连接，但是由于有些浏览器和服务器对URL的长度和字符格式存在限制，所以传递的信息有限；POST则把需要传递的数据放到请求报文的消息体中，HTTP协议对此没有限制，因此可以传递更多信息。
* 安全性：GET提交的数据，消息以明文出现在URL上，如密码等信息可能被浏览器缓存，从而从历史记录中得到；POST把消息存放在消息体中，安全性高，但是也存在被抓包软件抓取看到内容。



## HTTP状态

服务器返回的 **响应报文** 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。

| 状态码 | 类别                             | 原因短语                   |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |



## HTTP 和 HTTPS 的区别？
1. 端口 ：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。
2. 安全性和资源消耗： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源

## HTTP 长连接, 短连接

* 短连接 : 客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接
* 长连接(响应头加入这行代码 `Connection:keep-alive`) :，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间


## HTTP 是不保存状态的协议, 如何保存用户状态?
> HTTP 协议自身不对请求和响应之间的通信状态进行保存

Session 的主要作用就是通过服务端记录用户的状态
* 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。
* 服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session)
* 保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。
* Session 存放在服务器端，实现 Session 跟踪大部分情况下 通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

> Cookie 被禁用怎么办?
最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。


## Cookie 的作用是什么? 和 Session 有什么区别？

Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

Cookie 一般用来保存用户信息 
* 我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；
* 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；
* 登录一次网站后访问网站其他页面不需要重新登录。

Session 的主要作用就是通过服务端记录用户的状态。 
* 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。
* 服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密

